<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Cosmos Prototype</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<style>
  /* ---- Base ---- */
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  }

  /* ---- Generic UI card ---- */
  .ui {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    text-align: center;
    z-index: 10;
    background: rgba(0,0,0,.55);
    padding: 16px 22px;
    border-radius: 14px;
    width: min(92vw, 520px);
  }
  .small { font-size: 13px; opacity: .85; margin-top: 8px; }
  .hidden { display: none; }

  /* ---- Audio gate visual tweaks ---- */
  #audioGate {
    z-index: 999;
    background: rgba(0,0,0,.86);
    box-shadow: 0 10px 40px rgba(0,0,0,.5);
  }

  /* ---- Rotated UI plane for landscape-right (Safari PWA safe) ---- */
  #ui-rotor {
    position: fixed;

    /* center, compensating for iOS safe-area */
    left: calc(50% + (env(safe-area-inset-right) - env(safe-area-inset-left)) / 2);
    top:  calc(50% + (env(safe-area-inset-bottom) - env(safe-area-inset-top)) / 2);

    /* swap w/h so the rotated plane covers the screen */
    width: 100vh;
    height: 100vw;

    transform: translate(-50%, -50%) rotate(90deg);
    transform-origin: center center;

    z-index: 999;
    pointer-events: none; /* inner cards re-enable */
  }

  /* Re-center each .ui card inside the rotated plane */
  #ui-rotor .ui {
    position: absolute;              /* override base .ui fixed */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    max-width: min(92vmin, 520px);   /* vmin sizes better when rotated */
    width: auto;
    pointer-events: auto;            /* clickable again */
  }

  /* Optional subtle overall shrink to avoid headset edges */
  @supports (scale: 0.95) {
    #ui-rotor { scale: 0.96; }
  }
  /* --- Recommendations overlay --- */
  #recsOverlay.ui {
  width: min(92vmin, 680px);
  max-width: 92vmin;
  padding: 18px 20px;
  }

  #recsOverlay h3 {
  margin: .2rem 0 .6rem;
  }

.recs-row {
  display: flex;
  gap: 10px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding: 6px 2px 2px;
  margin: 8px 0 12px;
}

.recs-row img {
  height: 140px;              /* nice size in the rotated plane */
  border-radius: 8px;
  opacity: .95;
  display: block;
}

#recsCloseBtn {
  appearance: none;
  border: 0;
  border-radius: 10px;
  padding: 10px 14px;
  background: rgba(255,255,255,.12);
  color: #fff;
  font: inherit;
}
#recsCloseBtn:active { transform: scale(0.98); }
</style>
</head>

<body>

<div id="ui-rotor">
<!-- MENU UI -->
<div id="menu" class="ui">
  <h2 style="margin:.2rem 0 0.6rem">Silica Sky</h2>
  <p style="margin:.2rem 0 .8rem; opacity:.9">A single idea cluster in a vast cosmos. Walk the path, discover connections.</p>
  <p class="small" style="margin-top:0.6rem; opacity:0.85;">
  Controls: <b>W</b> = proceed • <b>S</b> = back • <b>A/D</b> = steer
  </p>
  <div style="text-align:left; margin:.6rem auto 0; line-height:1.6">
    <div>• <b>Press W</b> — Visit existing cluster</div>
    <div>• <b>Press S</b> — Create new cluster (placeholder)</div>
  </div>
  <div class="small">Use the foil pads.</div>
</div>

<!-- PLACEHOLDER UI FOR "CREATE NEW CLUSTER" -->
<div id="create" class="ui hidden">
  <h3 style="margin:.2rem 0 .6rem">Create New Cluster</h3>
  <p style="margin:.2rem 0 .8rem; opacity:.9">
    In the full system, this would start a new idea cluster. For this prototype, it’s a concept stub.
  </p>
  <div>• <b>Press S</b> — Back to menu</div>
</div>

<!-- DECISION UI AT THE END -->
<div id="decision" class="ui hidden">
  <h3 style="margin:.2rem 0 .6rem">Decision: What next?</h3>
  <div style="text-align:left; line-height:1.6">
    <div>• <b>Press W</b> — Continue building the cluster</div>
    <div class="small" style="margin:.4rem 0 .6rem 1.2rem">Press<b>W</b> to see suggested pieces</div>
    <div>• <b>Press S</b> — Leave cluster</div>
  </div>
</div>

<!-- ONE-TIME AUDIO GATE -->
<div id="audioGate" class="ui">
  <h3 style="margin:.2rem 0 .6rem">Enable Audio</h3>
  <p style="margin:.2rem 0 .8rem; opacity:.9">
    Tap once to enable sound. Then insert phone into the viewer.
  </p>
  <div class="small">This is required by iOS for audio playback.</div>
  <div style="margin-top:.8rem; opacity:.8">👆 Tap anywhere</div>
</div>

<!-- TUTORIAL: deletion hint shown once on first explore -->
<div id="tutorialDelete" class="ui hidden" style="opacity:.95;">
  <h3 style="margin:.3rem 0 .6rem">Deleting Artworks</h3>
  <p style="margin:.2rem 0 .8rem; opacity:.9; line-height:1.4;">
    Wave once to <b>arm</b> an artwork.<br/>
    Wave again to <b>hide</b> it.
  </p>
</div>
<!-- ✅ RECOMMENDATIONS OVERLAY (hidden until W at final node) -->
<div id="recsOverlay" class="ui hidden" aria-hidden="true">
  <h3>Suggested pieces</h3>
  <div id="recsRow" class="recs-row"></div>
  <button id="recsCloseBtn" type="button">I like it.</button>
</div>
</div>


<a-scene renderer="colorManagement:true" background="color:#01040c" fog="type: linear; color: #01040c; near: 8; far: 45" hide-artnode-on-e="requireConfirm: true; confirmWindow: 1200">
  <!-- Audio assets -->
  <a-assets>
  <audio id="sfxHide" src="assets/pop-deletion.mp3" crossorigin="anonymous"></audio>
  </a-assets>

  <!-- Single audio emitter (triggered from JS) -->
  <a-entity id="audioHide" sound="src: #sfxHide; poolSize: 4; volume: 0.85"></a-entity>

  <a-entity id="stars"></a-entity>

  <!-- Camera rig -->
  <a-entity id="rig" position="0 1.45 6">
    <a-entity id="cam"
      camera
      look-controls="pointerLockEnabled: false; touchEnabled: true; magicWindowTrackingEnabled: true"
      wasd-controls="acceleration: 14">
    </a-entity>
  </a-entity>

  <a-entity id="path"></a-entity>
  <a-entity id="nodes"></a-entity>
  <a-entity id="finalNode"></a-entity>

  <a-entity light="type: ambient; intensity: 0.45"></a-entity>
  <a-entity light="type: point; intensity: 0.9; distance: 20" position="0 3 0"></a-entity>
</a-scene>

<script>
/* ---------- STATE ---------- */
let state = 'menu'; // 'menu' | 'create' | 'explore' | 'decision'
window.state = state; // expose to components that read window.state
const uiMenu = document.getElementById('menu');
const uiCreate = document.getElementById('create');
const uiDecision = document.getElementById('decision');
if (!window.__audioUnlocked) uiMenu.classList.add('hidden');


function setState(next) {
  state = next;
  window.state = state; // keep global in sync
  uiMenu.classList.toggle('hidden', state !== 'menu');
  uiCreate.classList.toggle('hidden', state !== 'create');
  uiDecision.classList.toggle('hidden', state !== 'decision');
  const c = document.querySelector('a-scene').canvas;
  if (c) c.focus();
}

window.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();
  if (state === 'menu') {
    if (k === 'w') startExplore();
    if (k === 's') setState('create');
  } else if (state === 'create') {
    if (k === 's') setState('menu');
  } else if (state === 'decision') {
  if (k === 'w') {
    if (isRecsOpen()) {
      // Overlay is already visible → thank you + reload
      hideRecommendationsAndRestartWithThanks();
    } else {
      // First W → open overlay
      showRecommendations();
    }
  }
  if (k === 's') {
    // S should always be a quick exit (no overlay)
    hideRecommendationsAndRestart(); // uses default "Leaving cluster…"
  }
  }
});

document.getElementById('recsCloseBtn')?.addEventListener('click', hideRecommendationsAndRestartWithThanks);


function unlockAudioOnce() {
  if (window.__audioUnlocked) return;

  // Focus the canvas for controls
  const c = document.querySelector('a-scene')?.canvas;
  if (c) c.focus();

  // One-time WebAudio unlock (BLE keys don't count as a gesture)
  const hide = document.querySelector('#audioHide');
  try {
    hide?.components?.sound?.playSound();
    hide?.components?.sound?.stopSound();
    window.__audioUnlocked = true;
  } catch(e) { /* noop */ }

  // Dismiss the overlay
  const gate = document.getElementById('audioGate');
  if (gate) gate.classList.add('hidden');

  // show the menu now that audio is unlocked
  uiMenu.classList.remove('hidden');
}

// Unlock on first tap OR click (helps desktop testing too)
document.addEventListener('touchend', unlockAudioOnce, { passive: true });
document.addEventListener('click',     unlockAudioOnce, { passive: true });


/* ---------- BUILD SCENE ---------- */
const TOTAL_NODES = 12;
const RADIUS = 6;
const ART_REVEAL_DIST = 2.8;
const DOT_HIDE_T = 0.18;   // hide the dot once the image is ~18% revealed
const ART_OPAQUE_T = 0.50; // from 50% revealed, make the image fully opaque

const nodesEl = document.getElementById('nodes');
const pathEl  = document.getElementById('path');
const finalEl = document.getElementById('finalNode');

(function buildStars(){
  const stars = document.getElementById('stars');
  for (let i=0;i<200;i++){
    const s = document.createElement('a-sphere');
    const r = 30 + Math.random()*30;
    const theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
    const x = r*Math.sin(phi)*Math.cos(theta);
    const y = r*Math.cos(phi);
    const z = r*Math.sin(phi)*Math.sin(theta);
    s.setAttribute('position', `${x} ${y} ${z}`);
    s.setAttribute('radius', 0.02);
    s.setAttribute('material', 'color:#98a; emissive:#98a; emissiveIntensity:0.9; opacity:0.85; transparent:true');
    stars.appendChild(s);
  }
})();

/* ---------- Ground ribbon path ---------- */
const PATH_WIDTH = 0.45;
const PATH_HEIGHT_OFFSET = 0.02;
const PATH_EMISSIVE = '#6dd';
const PATH_OPACITY = 0.30;
const PATH_EMISSIVE_INT = 0.22;

function buildSCurve() {
  const pts = [
    {x:-4, y:0, z:6},
    {x:-1.5, y:0, z:2.5},
    {x:1.5, y:0, z:-1.0},
    {x:4.0, y:0, z:-4.5},
    {x:6.5, y:0, z:-8.0},
  ];

  while (pathEl.firstChild) pathEl.removeChild(pathEl.firstChild);

  for (let i = 0; i < pts.length - 1; i++) {
    const a = pts[i], b = pts[i+1];
    const dx = b.x - a.x, dz = b.z - a.z, dy = b.y - a.y;
    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const mid = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 + PATH_HEIGHT_OFFSET, z:(a.z+b.z)/2 };
    const yawDeg = Math.atan2(dx, dz) * 180/Math.PI;

    const seg = document.createElement('a-plane');
    seg.setAttribute('position', `${mid.x} ${mid.y} ${mid.z}`);
    seg.setAttribute('rotation', `-90 ${yawDeg} 0`);
    seg.setAttribute('width', PATH_WIDTH);
    seg.setAttribute('height', len.toFixed(3));
    seg.setAttribute('material', `
      color: ${PATH_EMISSIVE};
      emissive: ${PATH_EMISSIVE};
      emissiveIntensity: ${PATH_EMISSIVE_INT};
      opacity: ${PATH_OPACITY};
      transparent: true;
      side: double;
    `);
    pathEl.appendChild(seg);
  }
  return pts[pts.length - 1];
}

/* ---------- Nodes ---------- */
// Builds all node positions + visual representations in the cluster
function buildNodes() {
  // approximate center of the cluster
  const center = {x:1.2, y:1.2, z:-1.2};

  // which node indices will be “art nodes” (have image planes)
  const artIdx = new Set([2,5,8,11]);

  // list to keep track of all placed node positions (for spacing)
  const placed = [];

  // minimum allowed distance between any two nodesa
  const MIN_DIST = 1.4;

  // create 12 total nodes (some are art nodes, others just dots)
  for (let i = 0; i < 12; i++) {
    let px, py, pz;
    let tries = 0;

    // keep picking random positions until spacing looks good
    while (true) {
      // random radius offset
      const rr = RADIUS * (0.4 + Math.random() * 0.6);
      // random horizontal angle
      const ang = Math.random() * Math.PI * 2;
      // random small height offset
      const h   = (Math.random() * 1.2) - 0.6;

      // calculate new coordinates based on polar math + some jitter
      px = center.x + Math.cos(ang) * rr * 0.4 + (Math.random() * 1.2 - 0.6);
      py = 1.2 + h;
      pz = center.z + Math.sin(ang) * rr * 0.7 + (Math.random() * 1.2 - 0.6);

      // check distance against every previously placed node
      const ok = placed.every(p => {
        const dx = p.x - px, dy = p.y - py, dz = p.z - pz;
        // Euclidean distance formula
        return Math.sqrt(dx*dx + dy*dy + dz*dz) >= MIN_DIST;
      });

      // stop once spacing is OK or after 25 attempts
      if (ok || tries++ > 25) break;
    }

    // store this new node’s position for later spacing checks
    placed.push({ x: px, y: py, z: pz });

    // create the node container entity
    const node = document.createElement('a-entity');
    node.setAttribute('position', `${px.toFixed(2)} ${py.toFixed(2)} ${pz.toFixed(2)}`);

    // add the glowing blue sphere (the visual “node”)
    const dot = document.createElement('a-sphere');
    dot.classList.add('dot'); // gives us a handle to hide it later
    dot.setAttribute('radius', artIdx.has(i) ? 0.13 : 0.08);
    dot.setAttribute(
      'material',
      `color:#8cf; emissive:#8cf; emissiveIntensity:${artIdx.has(i)?'0.85':'0.55'}; opacity:${artIdx.has(i)?'0.95':'0.8'}; transparent:true`
    );
    node.appendChild(dot);

    // if this node is an art node, attach an image plane slightly in front
    if (artIdx.has(i)) {
      const plane = document.createElement('a-plane');
      plane.setAttribute('width', '1.0');      // image width
      plane.setAttribute('height','1.4');      // image height
      plane.setAttribute('position', '0 0 0.22'); // shift forward so it sits in front of the dot
      plane.setAttribute('rotation','0 0 0');     // face forward
      // start invisible; the art-revealer component fades this in
      plane.setAttribute('material','shader: flat; color:#ffffff; opacity:0; transparent:true; side: double');
      plane.classList.add('art');
      node.appendChild(plane);
    }

    // finally add this node to the global node container
    nodesEl.appendChild(node);
  }
}


function assignArtImages() {
  // Step 1: Create a list of all image file paths you want to use
  const files = [
    "assets/image01.jpeg",
    "assets/image02.jpeg",
    "assets/image03.jpeg",
    "assets/image04.jpeg",
    "assets/image05.jpeg",
    "assets/image06.jpeg",
    "assets/image07.jpeg", 
    "assets/image08.jpeg"  
  ];

  // Step 2: Pick how many of those images to actually use
  // since only 4 art nodes exist, take the first 4.
  const chosen = files.slice(0, 4);

  // Step 3: Find all <a-plane> elements that have the 'art' class (those are the art nodes)
  const planes = Array.from(document.querySelectorAll('#nodes .art'));

  // Step 4: For each art plane, assign an image from the chosen list
  planes.forEach((p, i) => {
    const src = chosen[i % chosen.length]; // loops images if fewer than planes
    // Step 5: Apply A-Frame material settings
    p.setAttribute(
      'material',
      `shader: flat; src: ${src}; opacity: 0; transparent: true; side: double`
    );
    p.setAttribute('render-order', '10');
  });
}

// Files I have in /assets; first 4 are used on planes, the rest become recommendations
const ALL_FILES = [
  "assets/image01.jpeg","assets/image02.jpeg","assets/image03.jpeg","assets/image04.jpeg",
  "assets/image05.jpeg","assets/image06.jpeg","assets/image07.jpeg","assets/image08.jpeg"
];
const USED_ON_PLANES = ALL_FILES.slice(0, 4);
const REC_FILES = ALL_FILES.slice(4); // show any (or all) that aren't on the planes


/* ---------- Reveal-on-approach ---------- */
AFRAME.registerComponent('art-revealer', {
  init() {
    this.cam = document.getElementById('cam');

    // collect pairs: { plane, dot }
    const nodes = Array.from(document.querySelectorAll('#nodes a-entity'));
    this.pairs = nodes.map(n => ({
      plane: n.querySelector('.art'),
      dot:   n.querySelector('.dot')
    })).filter(p => p.plane && p.dot);

    this._camWorld = new THREE.Vector3();
    this._artWorld = new THREE.Vector3();
  },
  tick() {
    if (!this.cam) return;
    this.cam.object3D.getWorldPosition(this._camWorld);

    this.pairs.forEach(({plane, dot})=>{
      // NEW: if node/plane was hidden (via E), skip all reveal logic
      if (!plane.object3D.visible || plane.getAttribute('visible') === false) return;

      plane.object3D.getWorldPosition(this._artWorld);
      const d = this._camWorld.distanceTo(this._artWorld);

      // progress 0 to 1 as user approaches
      const t = Math.min(1, Math.max(0, 1 - (d / ART_REVEAL_DIST)));

      // image opacity: fade in, then snap to fully opaque a bit early
      let imgOpacity = 0.05 + t * 0.95;
      let transparent = true;
      let depthTest = true;
      let depthWrite  = false;
      if (t >= ART_OPAQUE_T) { imgOpacity = 1; transparent = false; depthTest = true; depthWrite = true;}

      // keep existing src
      const mat = plane.getAttribute('material') || {};
      const src = mat.src || (plane.getAttribute('material') && plane.getAttribute('material').src);

      plane.setAttribute('material',
        `shader: flat; src: ${src}; opacity:${imgOpacity}; transparent:${transparent}; side: double; depthTest:${depthTest}; depthWrite:${depthWrite}`
      );

      // NEW: skip dot updates if node is hidden
      if (!dot.object3D.visible || dot.getAttribute('visible') === false) return;

      // dot: start fading early, then hide completely once t passes threshold
      if (t > DOT_HIDE_T) {
        dot.setAttribute('visible', false);
      } else {
        dot.setAttribute('visible', true);
        const baseEm = (dot.getAttribute('material')?.emissiveIntensity) ?? 0.85;
        const fade = Math.max(0, 1 - (t / DOT_HIDE_T)); // 1→0 as t approaches threshold
        dot.setAttribute('material',
          `color:#8cf; emissive:#8cf; emissiveIntensity:${baseEm}; opacity:${(0.9*fade).toFixed(2)}; transparent:true`
        );
      }
    });
  }
});

/* ---------- Hide nearest art node on "E" press (two-press confirm, sound on delete) ---------- */
AFRAME.registerComponent('hide-artnode-on-e', {
  schema: {
    radius:        { type: 'number', default: 1.6 },
    requireConfirm:{ type: 'boolean', default: true },
    confirmWindow: { type: 'number', default: 1200 }
  },

  init: function () {
    this.onKeyDown = this.onKeyDown.bind(this);
    window.addEventListener('keydown', this.onKeyDown, { passive: true });

    this.camEl = document.getElementById('cam');
    this._camWorld = new THREE.Vector3();
    this._tmp = new THREE.Vector3();

    this.sfxHide = document.querySelector('#audioHide');

    this.armed = null; // { node, expiresAt }
    this._disarmTimer = null;
  },

  remove: function () {
    window.removeEventListener('keydown', this.onKeyDown);
    if (this._disarmTimer) clearTimeout(this._disarmTimer);
  },

  nearestVisibleArtPlane: function () {
    var planes = Array.from(document.querySelectorAll('#nodes .art'))
      .filter(function (p) { return p.object3D.visible && p.getAttribute('visible') !== false; });

    if (!this.camEl || planes.length === 0) return { plane: null, dist: Infinity };

    this.camEl.object3D.getWorldPosition(this._camWorld);
    var nearestPlane = null, nearestDist = Infinity;

    for (var i = 0; i < planes.length; i++) {
      var p = planes[i];
      p.object3D.getWorldPosition(this._tmp);
      var d = this._camWorld.distanceTo(this._tmp);
      if (d < nearestDist) { nearestDist = d; nearestPlane = p; }
    }
    return { plane: nearestPlane, dist: nearestDist };
  },

  hideNode: function (node, dist) {
    node.emit('hidden-by-user', { key: 'e', distance: dist }, false);
    node.setAttribute('visible', false);
    node.classList.remove('clickable');
    var snd = this.sfxHide && this.sfxHide.components && this.sfxHide.components.sound;
    if (snd) snd.playSound();
  },

  onKeyDown: function (e) {
    if (window.state !== 'explore') return;
    var key = e.key ? e.key.toLowerCase() : '';
    if (key !== 'e') return;

    var res  = this.nearestVisibleArtPlane();
    var plane = res.plane;
    var dist  = res.dist;
    if (!plane || dist > this.data.radius) return;

    var node = plane.parentEl;
    var now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

    // Single-press fallback if requireConfirm=false
    if (!this.data.requireConfirm) { this.hideNode(node, dist); return; }

    // Confirm path: second E within window on same node
  if (this.armed && this.armed.node === node && now < this.armed.expiresAt) {
  var dotC = node.querySelector('.dot');
  var artC = node.querySelector('.art');
  if (dotC) dotC.removeAttribute('animation__arm');
  if (artC) artC.removeAttribute('animation__arm_plane');

  this.armed = null;
  if (this._disarmTimer) { clearTimeout(this._disarmTimer); this._disarmTimer = null; }

  this.hideNode(node, dist);
  return;
}

    // (Re)arm path
    // 1) Clear previous pulses
    if (this.armed && this.armed.node) {
      var prevDot = this.armed.node.querySelector('.dot');
      var prevArt = this.armed.node.querySelector('.art');
      if (prevDot) {
        prevDot.removeAttribute('animation__arm');
        var mPrev = prevDot.getAttribute('material') || {};
        var basePrev = Number(mPrev.emissiveIntensity != null ? mPrev.emissiveIntensity : 0.85);
        prevDot.setAttribute(
          'material',
          'color:#8cf; emissive:#8cf; emissiveIntensity:' + basePrev +
          '; opacity:' + (mPrev.opacity != null ? mPrev.opacity : 0.9) +
          '; transparent:true'
        );
      }
      if (prevArt) prevArt.removeAttribute('animation__arm_plane');
    }

    // 2) Arm this node
    this.armed = { node: node, expiresAt: now + this.data.confirmWindow };

    // 3) Pulse dot if visible; else pulse plane
    var dot = node.querySelector('.dot');
    var art = node.querySelector('.art');
    var dotVisible = !!(dot && dot.object3D.visible && dot.getAttribute('visible') !== false);

    if (dotVisible) {
      dot.setAttribute(
        'animation__arm',
        'property: scale; to: 1.35 1.35 1.35; dur: 160; dir: alternate; loop: 2; easing: easeInOutSine'
      );
      var m = dot.getAttribute('material') || {};
      var baseEm = Number(m.emissiveIntensity != null ? m.emissiveIntensity : 0.85);
      dot.setAttribute(
        'material',
        'color:#8cf; emissive:#8cf; emissiveIntensity:' + (baseEm + 0.3).toFixed(2) +
        '; opacity:' + (m.opacity != null ? m.opacity : 0.9) +
        '; transparent:true'
      );
      setTimeout(function () {
        dot.setAttribute(
          'material',
          'color:#8cf; emissive:#8cf; emissiveIntensity:' + baseEm +
          '; opacity:' + (m.opacity != null ? m.opacity : 0.9) +
          '; transparent:true'
        );
      }, 300);
    } else if (art) {
      art.setAttribute(
        'animation__arm_plane',
        'property: scale; to: 1.08 1.08 1; dur: 160; dir: alternate; loop: 2; easing: easeInOutSine'
      );
    }

    // 4) Auto-disarm and cleanup
    if (this._disarmTimer) clearTimeout(this._disarmTimer);
    var self = this;
    var armedNodeRef = node;
    this._disarmTimer = setTimeout(function () {
      var d = armedNodeRef && armedNodeRef.querySelector ? armedNodeRef.querySelector('.dot') : null;
      var a = armedNodeRef && armedNodeRef.querySelector ? armedNodeRef.querySelector('.art') : null;
      if (d) d.removeAttribute('animation__arm');
      if (a) a.removeAttribute('animation__arm_plane');
      if (self.armed && self.armed.node === armedNodeRef) self.armed = null;
    }, this.data.confirmWindow + 50);
  }
});

/* ---------- Final node ---------- */
function buildFinalNode(anchor){
  const root = document.createElement('a-entity');
  const pos = `${anchor.x} 1.3 ${anchor.z}`;
  root.setAttribute('position', pos);

  const core = document.createElement('a-sphere');
  core.setAttribute('radius','0.22');
  core.setAttribute('material','color:#ffd580; emissive:#ffd580; emissiveIntensity:0.95; opacity:0.98; transparent:true');
  root.appendChild(core);

  for (let i=0;i<5;i++){
    const sat = document.createElement('a-sphere');
    sat.setAttribute('radius','0.06');
    sat.setAttribute('material','color:#fff; emissive:#fff; emissiveIntensity:0.8; opacity:0.9; transparent:true');
    const orbit = document.createElement('a-entity');
    const r = 0.7 + Math.random()*0.5;
    const speed = 3000 + Math.random()*2000;
    orbit.setAttribute('position','0 0 0');
    sat.setAttribute('position', `${r} 0 0`);
    orbit.appendChild(sat);
    orbit.setAttribute('animation', `property: rotation; to: 0 360 0; dur: ${speed}; easing: linear; loop: true`);
    root.appendChild(orbit);
  }

  root.setAttribute('final-proximity','');
  finalEl.appendChild(root);
}

/* ---------- Fixed world-space proximity ---------- */
AFRAME.registerComponent('final-proximity', {
  init(){
    this.cam = document.getElementById('cam');
    this.shown=false;
    this._camWorld = new THREE.Vector3();
    this._hereWorld = new THREE.Vector3();
  },
  tick(){
    if (!this.cam) return;
    this.cam.object3D.getWorldPosition(this._camWorld);
    this.el.object3D.getWorldPosition(this._hereWorld);
    const d = this._camWorld.distanceTo(this._hereWorld);
    if (d < 2.8 && !this.shown){
      this.shown = true;
      setState('decision');
    }
    if (d >= 3.2 && this.shown){
      this.shown = false;
      if (state==='decision') setState('explore');
    }
  }
});

/* ---------- Utilities ---------- */
function resetPlayer(){
  const rig = document.getElementById('rig');
  rig.setAttribute('position','0 1.6 6');
  rig.object3D.rotation.set(0,0,0);
}

// Smooth fade to black with text, then reload (centered in rotated UI)
// Smooth fade to black with text, then reload (centered in rotated UI)
function fadeAndReload(msg = 'Leaving cluster…') {
  const rotor = document.getElementById('ui-rotor') || document.body;

  const overlay = document.createElement('div');
  overlay.style.position = (rotor.id === 'ui-rotor') ? 'absolute' : 'fixed';
  overlay.style.left = '0';
  overlay.style.top = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.background = '#000';
  overlay.style.opacity = '0';
  overlay.style.transition = 'opacity 1.8s ease';
  overlay.style.zIndex = '1000';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.flexDirection = 'column';

  if (rotor.id === 'ui-rotor') {
    overlay.style.left = '50%';
    overlay.style.top = '50%';
    overlay.style.transform = 'translate(-50%, -50%)';
  }

  rotor.appendChild(overlay);

  const text = document.createElement('div');
  text.textContent = msg;
  text.style.color = '#fff';
  text.style.fontSize = '1.6rem';
  text.style.opacity = '0.92';
  text.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  text.style.letterSpacing = '0.06em';
  overlay.appendChild(text);

  requestAnimationFrame(() => { overlay.style.opacity = '1'; });
  setTimeout(() => { location.reload(); }, 2200);
}

function showRecommendations() {
  const panel = document.getElementById('recsOverlay');
  const row   = document.getElementById('recsRow');
  if (!panel || !row) return;

  // Populate once per session
  if (!row._populated) {
    row.innerHTML = '';
    const files = REC_FILES.length ? REC_FILES : USED_ON_PLANES; // fallback to used if needed
    files.forEach(src => {
      const img = document.createElement('img');
      img.src = src;
      img.alt = 'Suggested piece';
      row.appendChild(img);
    });
    row._populated = true;
  }

  panel.classList.remove('hidden');
  panel.setAttribute('aria-hidden', 'false');
}

function hideRecommendationsAndRestart() {
  const panel = document.getElementById('recsOverlay');
  if (panel) {
    panel.classList.add('hidden');
    panel.setAttribute('aria-hidden', 'true');
  }
  // reload the scene to "move on"
  fadeAndReload();
}
function isRecsOpen() {
  const panel = document.getElementById('recsOverlay');
  return panel && !panel.classList.contains('hidden');
}

function hideRecommendationsAndRestartWithThanks() {
  const panel = document.getElementById('recsOverlay');
  if (panel) {
    panel.classList.add('hidden');
    panel.setAttribute('aria-hidden', 'true');
  }
  fadeAndReload('Thanks for testing! Reloading…');
}


/* ---------- Start ---------- */
let built = false;
function startExplore(){
  setState('explore');
  if (!built){
    const last = buildSCurve();
    buildNodes();
    assignArtImages();
    buildFinalNode(last);
    document.querySelector('a-scene').setAttribute('art-revealer','');
    built = true;
  }
  resetPlayer();
  // --- One-time deletion tutorial ---
  const tut = document.getElementById('tutorialDelete');
  if (tut && !window._tutorialShown) {
  tut.classList.remove('hidden');
  setTimeout(() => tut.classList.add('hidden'), 7000);
  window._tutorialShown = true;
}
}

setState('menu');
</script>
</body>
</html>